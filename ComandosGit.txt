Estados	
	Modificado (modified);
	Preparado (staged/index)
	Consolidado (comitted);

Ajuda
	git help

Configuração
	git config --global user.name "Leonardo Comelli" = Setar usuário

	git config --global user.email leonardo@software-ltda.com.br = Setar email

	git config --global core.editor vim = Setar editor

	git config --global merge.tool vimdiff = Setar ferramenta de merge

	git config --global core.excludesfile ~/.gitignore = Setar arquivos a serem ignorados

	git config --list = Listar configurações


Repositório Local
	git init = Criar novo repositório local
 
	git status = Verificar estado dos arquivos/diretórios = Adicionar um arquivo em específico


Adicionar arquivo/diretório (staged area)

	git add meu_arquivo.txt = Adicionar um arquivo em específico

	git add meu_diretorio = Adicionar um diretório em específico

	git add . = Adicionar todos os arquivos/diretórios

	git add -f arquivo_no_gitignore.txt = Adicionar um arquivo que esta listado no .gitignore (geral ou do repositório)


Comitar arquivo/diretório
	git commit meu_arquivo.txt = Comitar um arquivo

	git commit meu_arquivo.txt meu_outro_arquivo.txt = Comitar vários arquivos

	git commit meuarquivo.txt -m "minha mensagem de commit" = Comitar informando mensagem


Remover arquivo/diretório
	git rm meu_arquivo.txt = Remover arquivo

	git rm -r diretorio = Remover diretório


Visualizar hitórico
	git log = Exibir histórico

	git log -p -2 = Exibir histórico com diff das duas últimas alterações

	git log --stat = Exibir resumo do histórico (hash completa, autor, data, comentário e qtde de alterações (+/-))

	git log --pretty=oneline = Exibir informações resumidas em uma linha (hash completa e comentário)

	git log --pretty=format:"%h - %an, %ar : %s" = Exibir histórico com formatação específica (hash abreviada, autor, data e comentário)

	git log -- <caminho_do_arquivo> = Exibir histório de um arquivo específico

	git log --summary -S<palavra> [<caminho_do_arquivo>] = Exibir histórico de um arquivo específico que contêm uma determinada palavra

	git log --diff-filter=M -- <caminho_do_arquivo> = Exibir histórico modificação de um arquivo

	git log --author=usuario = Exibir histório de um determinado autor

	git blame -L 12,22 meu_arquivo.txt = Exibir revisão e autor da última modificação de uma bloco de linhas Desfazendo operações

	git checkout -- meu_arquivo.txt = Desfazendo alteração local (working directory)

	git reset HEAD meu_arquivo.txt = Desfazendo alteração local (staging area)


	Unstaged changes after reset: = Se o resultado abaixo for exibido, o comando reset não alterou o diretório de trabalho.

	M	meu_arquivo.txt
	
	git checkout meu_arquivo.txt

Repositório Remoto
	git remote = Exibir os repositórios remotos

	git remote -v = Exibir os repositórios remotos

	git remote add origin git@github.com:leocomelli/curso-git.git = Vincular repositório local com um repositório remoto

	git remote show origin = Exibir informações dos repositórios remotos

	git remote rename origin curso-git = Renomear um repositório remoto

	git remote rm curso-git = Desvincular um repositório remoto

	git push -u origin master = Enviar arquivos/diretórios para o repositório remoto
	O primeiro push de um repositório deve conter o nome do repositório remoto e o branch.

	git push = Os demais pushes não precisam dessa informação

	Atualizar repositório local de acordo com o repositório remoto

	git pull = Atualizar os arquivos no branch atual

	git fecth = Buscar as alterações, mas não aplica-las no branch atual

	git clone git@github.com:leocomelli/curso-git.git = Clonar um repositório remoto já existente

	Tags

	git tag vs-1.1 = Criando uma tag leve

	git tag -a vs-1.1 -m "Minha versão 1.1" = Criando uma tag anotada

	Criando uma tag assinada
	Para criar uma tag assinada é necessário uma chave privada (GNU Privacy Guard - GPG).

	git tag -s vs-1.1 -m "Minha tag assinada 1.1" = Criando uma tag anotada	

	git tag -a vs-1.2 9fceb02 = Criando tag a partir de um commit (hash)

	git push origin vs-1.2 = Criando tags no repositório remoto

	git push origin --tags = Criando todas as tags locais no repositório remoto

	Branches
	O master é o branch principal do GIT.
	O HEAD é um ponteiro especial que indica qual é o branch atual. Por padrão, o HEAD aponta para o branch principal, o master.

	git branch bug-123 = Criando um novo branch

	git checkout bug-123 = Trocando para um branch existente
	
	Neste caso, o ponteiro principal HEAD esta apontando para o branch chamado bug-123.
	git checkout -b bug-456 = Criar um novo branch e trocar

	git checkout master = Voltar para o branch principal (master)

	git merge bug-123 = Resolver merge entre os branches

	Para realizar o merge, é necessário estar no branch que deverá receber as alterações. O merge pode automático ou manual. O merge automático será feito em arquivos textos que não sofreram alterações nas mesmas linhas, 
	já o merge manual será feito em arquivos textos que sofreram alterações nas mesmas linhas.
	A mensagem indicando um merge manual será:

	git branch = Apagando um branch
 
	git branch -v = git branch -d bug-123

	git branch --merged = Listar branches que já foram fundidos (merged) com o master

	git branch --no-merged = Listar branches que não foram fundidos (merged) com o master
	
	Criando branches no repositório remoto
	
	git push origin bug-123 = Criando um branch remoto com o mesmo nome
 
	git push origin bug-123:new-branch = Criando um branch remoto com nome diferente


	git checkout -b bug-123 origin/bug-123 = Baixar um branch remoto para edição



	git push origin:bug-123 =  Apagar branch remoto

	Rebasing
	
	git checkout experiment = Fazendo o rebase entre um o branch bug-123 e o master.
	git rebase master = Fazendo o rebase entre um o branch bug-123 e o master.
	
	###Stash

	Para alternar entre um branch e outro é necessário fazer o commit das alterações atuais para depois trocar para um outro branch. Se existir a necessidade de realizar a troca sem fazer o commit é possível criar um stash.
	O Stash como se fosse um branch temporário que contem apenas as alterações ainda não commitadas.

	git stash = Criar um stash

	git stash list = Listar stashes

	git stash apply = Voltar para o último stash

	git stash apply stash@{2} = Voltar para um stash específico
	
	Onde 2 é o indíce do stash desejado.

	Criar um branch a partir de um stash

	git stash branch meu_branch = Criar um branch a partir de um stash

	Reescrevendo o histórico

	git commit --amend -m "Minha nova mensagem" = Alterando mensagens de commit

	Alterar últimos commits

	git rebase -i HEAD~3 = Alterando os três últimos commits


	O editor de texto será aberto com as linhas representando os três últimos commits.

	pick f7f3f6d changed my name a bit
	pick 310154e updated README formatting and added blame
	pick a5f4a0d added catfile
	
	Altere para edit os commits que deseja realizar alterações.

	edit f7f3f6d changed my name a bit
	pick 310154e updated README formatting and added blame
	pick a5f4a0d added catfile
	
	Feche o editor de texto.
	Digite o comando para alterar a mensagem do commit que foi marcado como edit.
	
	git commit –amend -m “Nova mensagem”
	
	git rebase --continue = Aplique a alteração

	Atenção: É possível alterar a ordem dos commits ou remover um commit apenas mudando as linhas ou removendo.
	Juntando vários commits
	Seguir os mesmos passos acima, porém marcar os commtis que devem ser juntados com *squash

	git filter-branch --tree-filter 'rm -f passwords.txt' HEAD = Remover todo histórico de um arquivo
	
	Bisect
	O bisect (pesquisa binária) é útil para encontrar um commit que esta gerando um bug ou uma inconsistência entre uma sequência de commits.

	git bisect start = Iniciar pequinsa binária

	git bisect bad = Marcar o commit atual como ruim

	git bisect good vs-1.1 = Marcar o commit de uma tag que esta sem o bug/inconsistência

	O GIT irá navegar entre os commits para ajudar a indentificar o commit que esta com o problema. 
	Se o commit atual não estiver quebrado, então é necessário marca-lo como bom.
	
	O GIT irá navegar entre os commits para ajudar a indentificar o commit que esta com o problema. 
	Se o commit atual não estiver quebrado, então é necessário marca-lo como bom.
	git bisect good = Marcar o commit como bom
	
	Se o commit estiver com o problema, então ele deverá ser marcado como ruim.
	git bisect bad = Marcar o commit como ruim
	
	Depois de encontrar o commit com problema, para retornar para o HEAD utilize:
	git bisect reset = Finalizar a pesquisa binária


	
	
